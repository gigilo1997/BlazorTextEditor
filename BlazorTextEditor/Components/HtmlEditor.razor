@inject IJSRuntime JSRuntime

<div @ref="@QuillElement">
</div>

@code {
    private ElementReference QuillElement;
    private DotNetObjectReference<HtmlEditor>? DotNetRef;

    [Inject]
    public HttpClient Http { get; set; } = default!;

    [Parameter]
    public bool ShowToolbar { get; set; } = true;

    [Parameter]
    public string? Value { get; set; }

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [JSInvokable]
    public async Task OnQuillTextChanged(string html)
    {
        if (Value != html)
        {
            Value = html;
            await ValueChanged.InvokeAsync(html);
        }
    }

    [JSInvokable]
    public async Task<string> UploadImage(string base64, string fileName)
    {
        byte[] imageBytes = Convert.FromBase64String(base64);
        using var content = new MultipartFormDataContent();
        var fileContent = new ByteArrayContent(imageBytes);
        content.Add(fileContent, "file", fileName);

        var response = await Http.PostAsync("api/upload-image", content);
        if (response.IsSuccessStatusCode)
        {
            return await response.Content.ReadAsStringAsync();
        }
        else
        {
            throw new Exception("Upload failed");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            DotNetRef = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeAsync<object>(
                "QuillFunctions.createQuill",
                QuillElement,
                ShowToolbar,
                DotNetRef,
                Value);
        }
    }

    public async ValueTask DisposeAsync()
    {
        DotNetRef?.Dispose();
    }
}